# Лабораторная работа No 3
<h1> Преобразование Берроуза-Уилера (BWT) <\h1>

Данное преобразование позволяет выстроить символы в порядке следования
контекстов, т.е. символы, идущие в одном контексте, группируются вместе. Дадим
описание метода в версии, когда контекст (как это принято в теории информации)
образован предыдущими символами, а не последующими (как это делается во многих
поверхностных описаниях метода в Интернете).

Пусть дано сообщение (текст) <b>message<\b>. Составим массив из циклических сдвигов
влево исходного текста. Затем отсортируем массив, причем сравнение строк при
сортировке будем начинать с <i>предпоследнего<\i> символа, двигаясь к началу строки.

<table>

 <tr>
  <td>                        </td>
  <th> Исходный массив        </th>
  <th> Отсортированный массив </th>
 </tr>

 <tr>
  <td> 0                      </td>
  <td> message                </td>
  <td> emessag                </td>
 </tr>

 <tr>
  <td> 1                      </td>
  <td> essagem                </td>
  <td> essagem                </td>
 </tr>

 <tr>
  <td> 2                      </td>
  <td> ssageme                </td>
  <td> sagemes                </td>
 </tr>

 <tr>
  <td> 3                      </td>
  <td> sagemes                </td>
  <td> message                </td>
 </tr>

 <tr>
  <td> 4                      </td>
  <td> agemess                </td>
  <td> ssageme                </td>
 </tr>

 <tr>
  <td> 5                      </td>
  <td> gemessa                </td>
  <td> agemess                </td>
 </tr>

 <tr>
  <td> 6                      </td>
  <td> emessag                </td>
  <td> gemessa                </td>
 </tr>

</table>

Результатом преобразования является последний столбец отсортированного
массива с указанием позиции в нем первого символа исходного текста. В нашем случае
результат преобразования будет <b> gmseesa 1 </b>. Мы видим, что буквы выстроены по
контекстам, упорядоченным в алфавитном порядке.

Обратное преобразование делается так. Сортируем буквы в алфавитном порядке,
запоминая их исходные позиции, т.е. получаем массив пар <буква, исходная позиция>,
упорядоченный по буквам (при этом одинаковые буквы должны быть упорядочены по
номерам позиций). Затем переписываем буквы во второй массив по номерам исходных
позиций, запоминая позицию буквы в первом (отсортированном) массиве. Начиная с
позиции, указанной как второй параметр преобразования (в нашем примере – 1),
переписываем букву из второго массива на выход, переходя на позицию буквы в
отсортированном массиве, и продолжаем этот процесс, пока не восстановим все
сообщение.

<table>
 
 <tr>
  <th>                              </th>
  <th> Вход                         </th>
  <th colspan="2"> Первый массив    </th>
  <th colspan="2"> Второй массив    </th>
  <th> Выход                        </th>
 </tr>
 
 <tr>
  <td> 0                            </td>
  <td> g                            </td>
  <td> a                            </td>
  <td> 6                            </td>
  <td> g                            </td>
  <td> 3                            </td>
  <td> m                            </td>
 </tr>
 
 <tr>
  <td> 1                            </td>
  <td> m                            </td>
  <td> e                            </td>
  <td> 3                            </td>
  <td> m                            </td>
  <td> 4                            </td>
  <td> e                            </td>
 </tr>
 
 <tr>
  <td> 2                            </td>
  <td> s                            </td>
  <td> e                            </td>
  <td> 4                            </td>
  <td> s                            </td>
  <td> 5                            </td>
  <td> s                            </td>
 </tr>
 
 <tr>
  <td> 3                            </td>
  <td> e                            </td>
  <td> g                            </td>
  <td> 0                            </td>
  <td> e                            </td>
  <td> 1                            </td>
  <td> s                            </td>
 </tr>
 
 <tr>
  <td> 4                            </td>
  <td> e                            </td>
  <td> m                            </td>
  <td> 1                            </td>
  <td> e                            </td>
  <td> 2                            </td>
  <td> a                            </td>
 </tr>
 
 <tr>
  <td> 5                            </td>
  <td> s                            </td>
  <td> s                            </td>
  <td> 2                            </td>
  <td> s                            </td>
  <td> 6                            </td>
  <td> g                            </td>
 </tr>
 
 <tr>
  <td> 6                            </td>
  <td> a                            </td>
  <td> s                            </td>
  <td> 5                            </td>
  <td> a                            </td>
  <td> 0                            </td>
  <td> e                            </td>
 </tr>

</table>

<b>Задание на ЛР</b>. 

Запрограммировать прямое и обратное преобразование BWT.
Подвергнуть результат преобразования сжатию методом "Стопка книг". Сравнить степени
сжатия при применении "Стопки книг" к исходному и преобразованному текстам. При
реализации BWT желательно использовать хороший метод сортировки, например, QSort.
Аудиторное время на выполнение и защиту работы – 4 часа.

